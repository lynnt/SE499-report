\chapter{Extending GDB for \uCPP}
\section{Design Constraints}
As mentioned in Chapter \ref{GDB}, there are several ways to extend GDB. However,
there are a few design constraints on the selected mechanism. Extension
mechanism for \uCPPS is simple, easy to implement, and versatile.

Regardless of which mechanism selected for extending GDB, all the functions
implemented should maintain similar functionality to existing GDB commands. In addition to functional
requirements, user usability and flexibility are additional requirements for this
project. These final requirements enable developers to be productive quickly
and do more with the extensions.

\section{Command usage}
\subsection{\uCPPS source code example}
\begin{lstlisting}[caption={\uCPPS source code used for GDB commands},
label={uCPP-src-code}]
_Task T
{
    void a()
    {
        while (1);
    }

    void main()
    {
        a();
    }
    public:
        T() {}
        T(const char* taskName, uCluster& x) : uBaseTask(taskName)
        {
            setName(taskName);
        }
};

int main()
{
    uProcessor procs[3];
    const int numTasks = 10;
    T tasks[numTasks];
}
\end{lstlisting}
Listing \ref{uCPP-src-code} shows the \uCPPS source code used to demonstrate
how existing GDB commands, which are specifcally for \uCPPS, work.
\subsection{Listing all clusters in a \uCPPS program}
\begin{lstlisting}[caption={clusters command}, label={clusters-command}]
(gdb) clusters
        Name            Address
    systemCluster       0x654200
    userCluster         0x7c3280
\end{lstlisting}
Listing \ref{clusters-command} shows a list of all clusters available in the system
along with the associated address.

\subsection{Listing all tasks in a cluster}
\begin{lstlisting}[caption={\text{cluster\_tasks} command}, label={cluster-tasks}]
(gdb) cluster_tasks 0x654200
    ID          Name            Address         State
    0       uProcessorTask      0x654200        uBaseTask::Blocked
    1       uSystemTask         0x7c3280        uBaseTask::Blocked
\end{lstlisting}
In listing \ref{cluster-tasks}, the command \verb|cluster_tasks| requires one
argument that is an address of a cluster. In this exampple, this command lists
all the name of the tasks in a cluster called \verb|systemCluster|.
Additionally, \verb|cluster_tasks| command also provides the associated address
for each task and its state.

\subsection{Listing all processors in a cluster}
\begin{lstlisting}[caption={\text{cluster\_procs} command}, label={cluster-procs}]
(gdb) cluster_procs 0x7c3280
    Address    PID         Preemption      Spin
    0x7c5bf0    8c92832     10              1000
    0x8c2b50    9449600     10              1000
    0x8c2d10    9973888     10              1000
    0x8c2ed0    10502272    10              1000
\end{lstlisting}
In the listing \ref{cluster-procs}, the command \verb|cluster_procs| expects one
argument, which is similar to command \verb|cluster_tasks|. This command shows
all the processors in a cluster. In particular, this example shows that there
are four processors in the cluster called \verb|userCluster|, and an address,
its PID, its premption priority and spin, which is how long a processor
repeatedly checks to see if a condition is true.

\subsection{Listing all tasks in all clusters}
\begin{lstlisting}[caption={\text{tasks} command}, label={tasks}]
(gdb) tasks
            Cluster Name        Address
            systemCluster       0x654200
        ID      Task Name            Address         State
        0       uProcessorTask      0x654200        uBaseTask::Blocked
        1       uSystemTask         0x7c3280        uBaseTask::Blocked
            Cluster Name        Address
            userCluster         0x7c3280
        ID      Task Name            Address         State
        0       uProcessorTask      0x805e70        uBaseTask::Blocked
        ...
        6       T                   0x8c0d00        uBaseTask::Running
        7       T                   0x8c1000        uBaseTask::Running
        8       T                   0x8c1300        uBaseTask::Ready
        ...
\end{lstlisting}
In the listing \ref{tasks}, the command \verb|tasks| does not require any
arugment since it lists out all the known tasks in a \uCPPS program at this
point of the snapshot of the execution.

\section{Design Implementation}
The GDB Python API satifies all the given criteria above after examining of different solutions. In particular, GDB provides an extensive API for
the programming language Python compared to other solutions. Furthermore, Python is a scripting language with built-in
data structures and functions that enables the development of more complex
operations and saves time on project development.

The first extension for GDB is writing new commands that allow
users to switch from one \uCCS task to another. Two switching approaches are
provided: structured and free form. The structured form remembers the task tour in a
LIFO way, meanwhile, the free form does not remember the task tour. This means
at least two commands are needed for the structured form and one is needed for
the free form. The first command is for switching from the current task to
the new task that can be called \verb|pushtask|, and another command
is for switching back to the previous task, from which the current task comes, and this command is named \verb|poptask|.

Prior to implementing either \verb|pushtask| or \verb|poptask| command, the
task argument had to be resolved. Should the \verb|pushtask| command use a task's address or the index of a cluster, and the index of a task with respect
to that cluster? Another issue needs to be resolved is if the structured or free
form approach should be selected.

As a result, both the structured and free form approaches are supported to
provide more flexibility to users. Furthermore, there are two variations of the \verb|pushtask| command to provide both usability and flexibility. The first variation is called \verb|pushtask| and requires
only one argument, which is the address of the task a user wants to switch to.
This option provides users with more flexibility if they know a
particular address they want to switch to. Listing \ref{pushtask} shows an example
of usage.

The second variation is called \verb|pushtask_id| and requires both the index of
the cluster and the index of the task to switch to. Core functionality of these two commands is
essentially the same. The only difference is that the \verb|pushtask_id| command
needs to iterate through the data structure that stores all the clusters to find
the right cluster based on its index, and using the found instance of the
cluster to search for the instance of the expected task. Furthermore, a decision
is made to store the context information for every context switching, this means
that \verb|pushtask| command needs to perform actions to store this information every time it is
invoked. Listing \ref{pushtask-id} shows an example of usage.

\begin{lstlisting}[language=Python, caption={Abridged \text{push\_task} source
code},
label={pushtask-code}]
# get GDB type of uContext_t*
uContext_t_ptr_type = \
gdb.lookup_type('UPP::uMachContext::uContext_t').pointer

# retrieve the context object from a task
task_context = task['context'].cast(uContext_t_ptr_type)

# lookup the value of stack pointer (sp), frame pointer (fp),
# program counter (pc)
xsp = task_context['SP'] + 48
xfp = task_context['FP']
if not gdb.lookup_symbol('uSwitch'):
    print('uSwitch symbol is not available')
    return

xpc = get_addr(gdb.parse_and_eval('uSwitch').address + 28, 'PC')
# must switch back to frame-0 to set 'pc' register with
# the value of xpc
gdb.execute('select-frame 0')

# retrieve register values and push sp, fp, pc into a global stack
global STACK
sp = gdb.parse_and_eval('$sp')
fp = gdb.parse_and_eval('$fp')
pc = gdb.parse_and_eval('$pc')
stack_info = StackInfo(sp = sp, fp = fp, pc = pc)
STACK.append(stack_info)

# update registers for a new task
gdb.execute('set $rsp={}'.format(xsp))
gdb.execute('set $rbp={}'.format(xfp))
gdb.execute('set $pc={}'.format(xpc))
\end{lstlisting}

Each task has a copy of \verb|uContext_t|, which stores the context
information such as stack pointer, frame pointer. These pointers are then
stored in an instance of the named tuple \verb|stackInfo| for every level of
redirection. The tuple also stores information about the program counter that
is calculated from the address of the \verb|uSwitch| Assembly routine. Similarly, the command
also retrieves these context information but from the task that a user wants to switch to, and
sets the equivalent registers to the new values. In particular, the value of the stack
pointer is set in \verb|rsp| register, the value of the frame pointer is set in \verb|rbp|
register, and finally the value of the program counter is set in \verb|pc| register.
For every new function call, a new stack frame is created and the values of all
the registers are changed for that frame. Therefore, in
order to see the true value of hardware registers, innermost frame that is
frame-0 must be selected \cite{reference11}. However, it is possible to not be in frame-0, so prior to setting these values,
the command must switch back to the innermost (currently executing) frame first.

Finally, the implementation of \verb|poptask| is more straightforward and does
not require different variations of the command. This command goes back to the previous task, however, this may not be the original
task that initiates the task switching process. If the current context is
already in the starting task, the command does nothing. Otherwise,
\verb|poptask| command first switches back to the innermost frame, and then
retrieves the
address of the last task it was switched from, and sets the same set of registers as
\verb|pushtask| command did but to the values of the last task's context
information. An example of this command can be seen in listing \ref{poptask}.

\begin{lstlisting}[caption={\text{pushtask} command}, label={pushtask}]
(gdb) pushtask 0x8c1300
\end{lstlisting}
The first variation of a command that allows context switching is \verb|pushtask|. This command requires an
address of a task that is not in terminated state that results into switching
into the stack of the exepected task. This command is shown in listing
\ref{pushtask}.

\begin{lstlisting}[caption={\text{pushtask\_id} command}, label={pushtask-id}]
(gdb) pushtask_id 1
\end{lstlisting}

Another variation of the same command above is \verb|pushtask_id|. This command
expects an identifier of a task, which can be obtained from either the command \verb|tasks| or
\verb|cluster_tasks|. This variation provides a simpler and easier to use
interface with the same functionality.

\begin{lstlisting}[caption={\text{poptask} command}, label={poptask}]
(gdb) poptask
\end{lstlisting}

This command allows users to go back to the previously context-switched task.
However, if a user performs any command that continues where the program last
stops/pauses, the program automatically reverses back to the task that initiates
the first context switch to allow continuation of a program based on the
command.

\section{Result}
The current implementation successfully allows users to perform context
switching among tasks as long as the destination task is not a terminated
task. Additionally, users are allowed to continue the execution where the
program last pauses assuming that the program has not crashed. The continuation
of execution can be done automatically by the extensions by running any already
existing GDB commands such as \verb|continue| or a user can manually
perform the reverse of context switch using the command \verb|poptask|.
