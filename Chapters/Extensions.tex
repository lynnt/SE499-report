\chapter{Extending GDB for \uCPP}
\section{Design Constraints}
As mentioned in Chapter \ref{GDB}, there are several ways to extend GDB. However,
there are a few design constraints on the selected mechanism. Extension
mechanism for \uCPPS is simple, easy to implement, and versatile.

Regardless of which mechanism selected for extending GDB, all the functions
implemented should maintain similar functionality to existing GDB commands. In addition to functional
requirements, user usability and flexibility are additional requirements for this
project. These final requirements enable developers to be productive quickly
and do more with the extensions.

\section{Command usage}
\subsection{\uCPPS source code example}
Below is the \uCPPS source code used to demonstrate how GDB commands work.
\begin{lstlisting}[caption={\uCPPS source code for GDB examples},
label={uC++-src-code}]
_Task T
{
    void a()
    {
        while (1);
    }

    void main()
    {
        a();
    }
    public:
        T() {}
        T(const char* taskName, uCluster& x) : uBaseTask(taskName)
        {
            setName(taskName);
        }
};

int main()
{
    uProcessor procs[3];
    const int numTasks = 10;
    T tasks[numTasks];
}
\end{lstlisting}
\subsection{Listing all clusters in a \uCPPS program}

\begin{lstlisting}[caption={clusters command}]
(gdb) clusters
        Name            Address
    systemCluster       0x654200
    userCluster         0x7c3280
\end{lstlisting}

\subsection{Listing all tasks in a cluster}
\begin{lstlisting}[caption={\text{cluster\_tasks} command}, label={cluster-tasks}]
(gdb) cluster_tasks 0x654200
    ID          Name            Address         State
    0       uProcessorTask      0x654200        uBaseTask::Blocked
    1       uSystemTask         0x7c3280        uBaseTask::Blocked
\end{lstlisting}
In listing \ref{cluster-tasks}, the command \verb|cluster_tasks| requires one
argument that is an address of a cluster. In this exampple, this command lists
all the name of the tasks in a cluster called \verb|systemCluster|.
Additionally, \verb|cluster_tasks| command also provides the associated address
for each task and its state.

\subsection{Listing all processors in a cluster}
\begin{lstlisting}[caption={\text{cluster\_procs} command}, label={cluster-procs}]
(gdb) cluster_procs 0x7c3280
    Address    PID         Preemption      Spin
    0x7c5bf0    8c92832     10              1000
    0x8c2b50    9449600     10              1000
    0x8c2d10    9973888     10              1000
    0x8c2ed0    10502272    10              1000
\end{lstlisting}
In the listing \ref{cluster-procs}, the command \verb|cluster_procs| expects one
argument, which is similar to command \verb|cluster_tasks|. This command shows
all the processors in a cluster. In particular, this example shows that there
are four processors in the cluster called \verb|userCluster|, and an address,
its PID, its premption priority and spin, which is how long a processor
repeatedly checks to see if a condition is true.
\subsection{Listing all clusters in a \uCPPS program}

\begin{lstlisting}[caption={clusters command}]
(gdb) clusters
        Name            Address
    systemCluster       0x654200
    userCluster         0x7c3280
\end{lstlisting}

\subsection{Listing all tasks in all clusters}
\begin{lstlisting}[caption={\text{tasks} command}, label={tasks}]
(gdb) tasks
            Cluster Name        Address
            systemCluster       0x654200
        ID      Task Name            Address         State
        0       uProcessorTask      0x654200        uBaseTask::Blocked
        1       uSystemTask         0x7c3280        uBaseTask::Blocked
            Cluster Name        Address
            userCluster         0x7c3280
        ID      Task Name            Address         State
        0       uProcessorTask      0x805e70        uBaseTask::Blocked
        ...
        6       T                   0x8c0d00        uBaseTask::Running
        7       T                   0x8c1000        uBaseTask::Running
        8       T                   0x8c1300        uBaseTask::Ready
        ...
\end{lstlisting}
In the listing \ref{tasks}, the command \verb|tasks| does not require any
arugment since it lists out all the known tasks in a \uCPPS program at this
point of the snapshot of the execution.

\subsection{Context switching between tasks}
\begin{lstlisting}[caption={\text{pushtask} command}, label={pushtask}]
(gdb) pushtask 0x8c1300
\end{lstlisting}
The first variation of a command that allows context switching is \verb|pushtask|. This command requires an
address of a task that is not in terminated state that results into switching
into the stack of the exepected task. This command is shown in listing
\ref{pushtask}.

\begin{lstlisting}[caption={\text{pushtask\_id} command}, label={pushtask-id}]
(gdb) pushtask_id 1
\end{lstlisting}
Another variation of the same command above is \verb|pushtask_id|. This command
expects an identifier of a task, which can be obtained from either the command \verb|tasks| or
\verb|cluster_tasks|. This variation provides a simpler and easier to use
interface with the same functionality.
\subsection{Reverse context switch of tasks}
\begin{lstlisting}[caption={\text{poptask} command}, label={poptask}]
(gdb) poptask
\end{lstlisting}
This command allows users to go back to the previously context-switched task.
However, if a user performs any command that continues where the program last
stops/pauses, the program automatically reverses back to the task that initiates
the first context switch to allow continuation of a program based on the
command.

\section{Design Implementation}
The GDB Python API satifies all the given criteria above after examining of different solutions. In particular, GDB provides an extensive API for
Python compared to other solutions. Furthermore, Python is a scripting language with built-in
data structures and functions that enables the development of more complex
operations and saves time on project development.

The first extensions for GDB is writing new commands that allow
users to switch from one \uCCS task to another. Two switching approaches are
provided: structured and free form. The structured form remembers the task tour in a
LIFO way, meanwhile, the free form does not remember the task tour. This means
at least two commands are needed for the structured form and one is needed for
the free form. The first command is for switching from the current task to
the new task that can be called \verb|push_task|, and another command
is for switching back to the previous task, from which the current task comes
from, and this command is named \verb|pop_task|.

Prior to implementing either \verb|pushtask| or \verb|poptask| command, the
task argument had to be resolved. Should the \verb|pushtask| command use a task's address or the index of a cluster, and the index of a task with respect
to that cluster? Another issue needs to be resolved is if the structured or free
form approach should be selected.

As a result, there are two variations of the \verb|pushtask| command to provide both usability and flexibility. The first variation is called \verb|pushtask| and requires
only one argument, which is the address of the task a user wants to switch to.
The second variation is called \verb|pushtask_id| and requires both the index of
the cluster and the index of the task to switch to. Core functionality of these two commands is
essentially the same. The only difference is that the \verb|pushtask_id| command
needs to iterate through the data structure that stores all the clusters to find
the right cluster based on its index, and using the found instance of the
cluster to search for the instance of the expected task. Furthermore, a decision
is made to store the context information for every context switching, this means
that \verb|pushtask| command needs to perform actions to store this information every time it is
invoked.
\\
TODO: show code
\\

Each task has a copy of \verb|uContext_t|, which stores the context
information such as stack pointer, frame pointer. These pointers are then stored
in convenience variables for every level of redirection. Similarly, the command
also retrieves these context information but from the task that a user wants to switch to, and
sets the equivalent registers to the new values. In particular, the value of the stack
pointer is set in \verb|rsp| register, the value of the frame pointer is set in \verb|rbp|
register, and finally the value of the program counter is set in \verb|pc| register.
\\
TODO: fix me\\
Normally, register values are relative to the current stack frame assuming that
all the stack frames farther already exited and their registers are restored. Therefore, in
order to see the true value of hardware registers, innermost frame that is
frame-0 must be selected\cite{reference11}. However, it is possible to not to be in frame-0, so prior to setting these values,
the command must switch back to the innermost (currently executing) frame first.

Finally, the implementation of \verb|poptask| is more straightforward and does
not require different variations of the command. This command goes back to the previous task, however, this may not be the original
task that initiates the task switching process. If the current context is
already in the starting task, the command does nothing. Otherwise,
\verb|poptask| command first switches back to the innermost frame, and then
retrieves the
address of the last task it was switched from, and sets the same set of registers as
\verb|pushtask| command did but to the values of the last task's context
information.

\section{Result}
TODO: fixme\\
The current implementation successfully allows users to switch from one task to
another task, but does not permit the switch if the destination task is an already terminated
task. However, if a user would like to continue the execution where it is left
off assuming that the program has yet crashed, then the user needs to perform
\verb|poptask| all the way back to the originating task before moving forward.
