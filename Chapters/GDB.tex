\chapter{GNU Debugger} \label{GDB}
\section{Introduction}
GBD is the GNU Project Debugger that allows a user to see what is going on
inside another program while it executes, or understand what a program was
doing at the moment it crashed\cite{reference3}.

\section{Debug Information}
In order to allow a user to effectively inspect their program's state, the
debugger requires the debugging information of that program. Debugging
information is a collection of data generated by a compiler or an assembler
program. This information is stored in an object file, and it describes
information such as the type of each variable or function and
the corresponce between source line numbers and addresses in the executable
code\cite{reference6}. To request for the generation of debugging information,
a user needs to specify the flag \verb|-g| during the compilation stage of the
program.

Specifically in GDB, DWARF is one of the supported debugging data format. DWARF is architecture
independent and applicable to any processor or operating system
\cite{reference7}. This format uses a data structure called DIE to represent
each variable, type, procedure, etc. A DIE consists of a pair of a tag
and its attribute\cite{reference8}.

\section{Stack Frame}
Stack frame, or frame for short, is a collection of all data associated with
one function call. A frame consists of local variables declared in that
function, arguments passed to the functions, and the address at which the
function is executing. Frame pointer register stores the address of a frame
while an execution of this frame is going on. A call stack can have many
frames\cite{reference12}.

\section{Extending GDB}
GDB provides three mechanisms for extending itself. The first is
composition of GDB commands, the second solution is using Python programming
language, and the third one is defining new aliases of existing commands.

\section{Symbol Handling}
Symbols are a key part of GDB's operation. Symbols can be variables, functions and
types. GDB has three types of symbol tables:
\begin{itemize}
    \item \textcolor{ForestGreen}{Full symbol tables (symtabs)}: These contain the main information
        about symbols and addresses
    \item \textcolor{ForestGreen} {Partial symbol tables (psymtabs)}: These contain enough information to
        know when to read the corresponding part of the full symbol table.
    \item \textcolor{ForestGreen}{Minimal symbol tables (msymtabs)}: These
        contain information extracted from non-debugging symbols.
\end{itemize}

Symbol information for a large program can be very large, and reading of all
these symbols can be a performance bottlenecks in GDB. This affects user
experience, so the solution is to construct partial symbol tables consisting of
only selected symbols, and then expand them to full symbol tables when
necessary.
A psymtab is constructed by doing a quick pass over the executable file's
debugging information.

\section{Name Demangling in GDB}
The library \verb|libiberty| provides many functions and features that can be
divided into three groups:
\begin{itemize}
    \item Supplemental functions: additional functions that can be missing in
        the underlying operating system.
    \item Replacement functions: simple and unified equivalent functions for
        commonly used standard routines.
    \item Extensions: provide additional functions beyond the standards.
\end{itemize}

In particular, this library provides \CPPS demangler that is used in GDB. A new
demangler can also be added in this library, which is what Rust did.
