\chapter{GNU Debugger} \label{GDB}
\section{Introduction}
GNU Project Debugger (GDB), which is a program, that allows examination what is going on
inside another program while it executes, or understand the state of a program
the moment it crashed\cite{reference3}.

\section{Debug Information}
In order to allow a user to effectively inspect their program's state, the
debugger requires the debugging information for that program. Debugging
information is a collection of data generated by a compiler and/or an assembler
program. This information is stored in an object file, and it describes
information such as the type of each variable or function and
the corresponce between source line numbers and addresses in the executable
code\cite{reference6}. Debugging information is generated by the flag \verb|-g| during the compilation stage of the
program.

Specifically in GDB, DWARF is one of the supported debugging data formats. DWARF is architecture
independent and applicable to any language, operating system, or processor 
\cite{reference7}. This format uses a data structure called DIE to represent
each variable, type, procedure, etc. A DIE is a pair: a tag
and its attribute\cite{reference8}.

\section{Stack Frame}
Stack frame, or frame for short, is a collection of all data associated with
one function call. A frame consists of arguments passed to the functions, local variables declared in that
function, arguments passed to the functions, and the address at which the
function is executing. The frame-pointer register stores the address of a frame,
during execution of this frame. A call stack can have many frames\cite{reference12}.

\section{Extending GDB}
GDB provides three mechanisms for extending itself. The first is
composition of GDB commands, the second solution is using Python programming
language, and the third one is defining new aliases of existing commands.

\section{Symbol Handling}
Symbols are a key part of GDB's operation. Symbols can be variables, functions and
types. GDB has three kinds of symbol tables:
\begin{itemize}
    \item \textcolor{ForestGreen}{Full symbol-tables (symtabs)}: These contain the main information
        about symbols and addresses
    \item \textcolor{ForestGreen} {Partial symbol-tables (psymtabs)}: These contain enough information to
        know when to read the corresponding part of the full symbol-table.
    \item \textcolor{ForestGreen}{Minimal symbol-tables (msymtabs)}: These
        contain information extracted from non-debugging symbols.
\end{itemize}

Symbol information for a large program can be very large, and reading of all
these symbols can be a performance bottlenecks in GDB and affecting the user
experience. The solution is to construct partial symbol-tables consisting of
only selected symbols, and then expand them to full symbol-tables when
necessary.
A psymtab is constructed by doing a quick pass over the executable file's
debugging information.

\section{Name Demangling in GDB}
The library \verb|libiberty| provides many functions and features that can be
divided into three groups:
\begin{itemize}
    \item \textcolor{ForestGreen}{Supplemental functions}: additional functions
        that may be missing in
        the underlying operating system.
    \item \textcolor{ForestGreen}{Replacement functions}: simple and unified equivalent functions for
        commonly used standard routines.
    \item \textcolor{ForestGreen}{Extensions}: additional functions beyond the standards.
\end{itemize}

In particular, this library provides the \CCS demangler that is used in GDB. A new
demangler can also be added in this library, which is what Rust did.
