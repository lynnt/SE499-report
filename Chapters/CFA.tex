\chapter{\CFA} \label{CFA}
\section{Introduction}
Similar to \CC, C is a popular programming language especially in system
programming. For example, Windows NT kernel and Linux kernel are written in C, and they are the foundation of many higher level
and popular projects. Therefore, it is unlikely that programming language C is
going to disappear any time soon.

However, C has inherent problems in syntactics, linkage, semantics and many
more. Even though \CCS is meant to fix these problems, \CCS has many
irreversible legacy design choices, and newer versions of \CCS require significantly more effort to convert C-based projects into \CCS.

To solve this problem, \CFAS is designed at the University of Waterloo. The goal
of the language is to extend C with modern language features that many new
languages have been known for such as Rust, Go. This extension provides a
backward-compatible version of C while fixing existing problems known in C and
modernizing the language at the same time.

\section{Overloading}
Overloading is when a compiler permits defining two different routines with
the same name. Most programming languages only allow operator and/or function overloading.
In addition to those functionalities, \CFAS also supports variables and literal
\verb|0/1| overloading.

\subsection{Variable}
Variables in the same block are allowed to have the same name as long as it is
differentiated by its type. An assignment of a new variable to the same variable is
deferred from type.
\begin{frame}
\frametitle{}
\begin{lstlisting}
short int MAX = 3;
int MAX = 4;
double MAX = 1.0;

// select variable MAX based on its left-hand type
short int s = MAX;      // MAX = 3
int max = MAX;          // MAX = 4
double max = MAX;       // MAX = 1.0
\end{lstlisting}
\end{frame}

\subsection{Routine}
Routines in the same block can be overloaded depending on the number and type of
parameters and returns.
\begin{frame}
\frametitle{}
\begin{lstlisting}
void f(<@\textcolor{red}{void}@>);              // (1)
void f(<@\textcolor{red}{char}@>);              // (2)
<@\textcolor{red}{char}@> f(void);              // (3)
<@\textcolor{red}{[int,double]}@> f();           // (4)

f();                        // pick (1)
f('a');                     // pick (2)
char s = f('a');            // pick (3)
[int, double] s = f();      // pick (4)
\end{lstlisting}
\end{frame}

\subsection{Operator}
An operator name is denoted with \verb|?| for the operand, and any standard C
operator. Operator names within the same block can be overloaded depending on
the number and type of parameters and returns. However, operators \verb|&&|,
\verb-||-, \verb|?:| cannot be overloaded because short-circuit semantics
cannot be preserved. This behaves as same as how \CCS behaves.
\begin{frame}
\frametitle{}
\begin{lstlisting}
int <@\textcolor{red}{++?}@>(int op);           // unary prefix increment
int <@\textcolor{red}{?++}@>(int op);           // unary postfix increment
int <@\textcolor{red}{?+?}@>(int op1, int op2); // unary postfix increment

struct A { double x, double y }

// overload operator plus-assignment
A <@\textcolor{red}{?+?}@>(S a, S b) {
    return (S) {a.x + b.x, a.y + b.y};
}
\end{lstlisting}
\end{frame}
