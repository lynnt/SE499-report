\chapter{\CFA} \label{CFA}
Similar to \CC, C is a popular programming language especially in system
programming. For example, Windows NT kernel and Linux kernel are written in C, and they are the foundation of many higher level
and popular projects. Therefore, it is unlikely that programming language C is
going to disappear any time soon.

However, C has inherent problems in syntactics, linkage, semantics and many
more\cite{reference2}. Even though \CCS is meant to fix these problems, \CCS has many
irreversible legacy design choices, and newer versions of \CCS require significantly more effort to convert C-based projects into \CCS.

To solve this problem, \CFAS is designed at the University of Waterloo. The goal
of the language is to extend C with modern language features that many new
languages have been known for such as Rust, Go. This extension provides a
backward-compatible version of C while fixing existing problems known in C and
modernizing the language at the same time.

\section{Overloading}
Overloading is when a compiler permits defining two different routines with
the same name. Most programming languages only allow operator and/or function overloading.
In addition to those functionalities, \CFAS also supports variables and literal
\verb|0/1| overloading.

\subsection{Variable}
Variables in the same block are allowed to have the same name as long as it is
differentiated by its type. An assignment of a new variable to the same variable is
deferred from type.


\begin{frame}
\frametitle{}
\begin{lstlisting}[caption={Overloading variables in \CFA}, label={CFA-overload-var}]
short int MAX = 3;
int MAX = 4;
double MAX = 1.0;

// select variable MAX based on its left-hand type
short int s = MAX;      // MAX = 3
int max = MAX;          // MAX = 4
double max = MAX;       // MAX = 1.0
\end{lstlisting}
\end{frame}

The listing \ref{CFA-overload-var} shows that when variable overloading exists
in the same scope, the selected variable is selected based on its type. For
instance, if the variable \verb|s| is declared with type \verb|int|, then its
value is 4 if variable \verb|MAX| is assigned to variable \verb|s|, which can
be seen on line 2 and 7.

\subsection{Routine}
Routines in the same block can be overloaded depending on the number and type of
parameters and returns.


\begin{frame}
\frametitle{}
\begin{lstlisting}[caption={Overloading routines in \CFA},
label={CFA-overload-func}]
void f(<@\textcolor{red}{void}@>);              // (1)
void f(<@\textcolor{red}{char}@>);              // (2)
<@\textcolor{red}{char}@> f(void);              // (3)
<@\textcolor{red}{[int,double]}@> f();           // (4)

f();                        // pick (1)
f('a');                     // pick (2)
char s = f('a');            // pick (3)
[int, double] s = f();      // pick (4)
\end{lstlisting}
\end{frame}

The listing \ref{CFA-overload-func} shows that when many routine are overloaded in
the same scope, a routine is selected based on the combination of its return type and its
arguments. For instance, from line 1-4, four different types of a routine called
\verb|f| is declared. If a routine \verb|f('a')| is called, then the appropriate
routine to invoke is the one on line 2 if the return type is \verb|void|, however, if
the return type is \verb|char|, then the routine on line 3 is selected. This
example can be seen on line 7-8.

\subsection{Operator}
An operator name is denoted with \verb|?| for the operand, and any standard C
operator. Operator names within the same block can be overloaded depending on
the number and type of parameters and returns. However, operators \verb|&&|,
\verb-||-, \verb|?:| cannot be overloaded because short-circuit semantics
cannot be preserved. This behaves as same as how \CCS behaves.


\begin{frame}
\frametitle{}
\begin{lstlisting}[caption={Overloading operators in \CFA},
label={CFA-overload-ops}]
int <@\textcolor{red}{++?}@>(int op);           // unary prefix increment
int <@\textcolor{red}{?++}@>(int op);           // unary postfix increment
int <@\textcolor{red}{?+?}@>(int op1, int op2); // unary postfix increment

struct A { double x, double y }

// overload operator plus-assignment
A <@\textcolor{red}{?+?}@>(S a, S b) {
    return (S) {a.x + b.x, a.y + b.y};
}
\end{lstlisting}
\end{frame}

The listing \ref{CFA-overload-ops} shows that operator overloading is permitted
similar how \CCS behaves. However, the difference is that the operator name is
denoted with \verb|?| instead.
