\chapter{\CFA} \label{CFA}
\section{Introduction}
\textbf{\textcolor{red}{TODO}}: rephrase all these stuff in my own word and cite

Similar to \CC, C is a popular programming language especially in systems such
as operating systems, embedded systems. For example, Windows NT kernel and
Linux kernel are written in C, and they are the foundation of many higher level
and popular projects. Therefore, it is unlikely that they will go away any time soon.

However, C has in syntactics, linkage, semantics and many
more. Even though \CCS is meant to fix these problems, \CCS has legacy design
choices that cannot be undone and newer versions of \CCS require significantly
more effort to convert C-based projects into \CCS.

To solve this problem, \CFAS is designed by the programming language group at the
University of Waterloo. The language's goal is to extend C with modern language
features that many new languages have been known for such as Rust, Go. This
extension provides a backward compatible version of C while fixing existing
problems known in C.

\section{Overloading}
\textbf{\textcolor{red}{TODO}}: write this please
\textbf{\textcolor{red}{TODO}}: add an example piece of code to demonstrate what
is overloading

Overloading is when a compiler that allows defining two different routines with
the same name, but there is a
In most programming languages, they only allow operator and/or function overloading.
In addition to those, \uCPP also supports variables and literal 0/1 overloading.

\subsection{Variables}
Variables in the same block are allowed to have the same name as long as it is
differentiated by type. An assignment of a new variable to the same variable is
deferred from type.
\begin{frame}
\frametitle{}
\lstset{language=C++,
        basicstyle=\ttfamily,
        keywordstyle=\color{blue}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{ForestGreen}\ttfamily,
        morecomment=[l][\color{magneta}]{\#}}
\begin{lstlisting}
short int MAX = 3;
int MAX = 4;
double MAX = 1.0;

// select variable MAX based on its left-hand type
short int s = MAX; // MAX = 3
int max = MAX; // MAX = 4
double max = MAX; // MAX = 1.0
\end{lstlisting}
\end{frame}

\subsection{Routine}
Routines in the same block can be overloaded depending on the number and type of
parameters and returns.
\begin{frame}
\frametitle{}
\lstset{language=C++,
        basicstyle=\ttfamily,
        keywordstyle=\color{blue}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{ForestGreen}\ttfamily,
        morecomment=[l][\color{magneta}]{\#}}
\begin{lstlisting}
void f(<@\textcolor{red}{void}@>);              // (1)
void f(<@\textcolor{red}{char}@>);              // (2)
<@\textcolor{red}{char}@> f(void);              // (3)
<@\textcolor{red}{[int,double]}@> f();          // (4)

f();                        // pick (1)
f('a');                     // pick (2)
char s = f('a');            // pick (3)
[int, double] s = f();      // pick (4)
\end{lstlisting}
\end{frame}

\subsection{Operator}
An operator name is denoted with \? for the operand and any standard C
operator. Operator names within the same block can be overloaded depending on
the number and type of parameters and returns. However, operators \textit{??},
\textit{||}, \textit{?:} cannot be overloaded because short-circuit semantics
cannot be preserved. This behaves as same as how \CCS behaves.
\begin{frame}
\frametitle{}
\lstset{language=C++,
        basicstyle=\ttfamily,
        keywordstyle=\color{blue}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{ForestGreen}\ttfamily,
        morecomment=[l][\color{magneta}]{\#}}
\begin{lstlisting}
int <@\texcolor{red}{++?}@>(int op);            // unary prefix increment
int <@\textcolor{red}{?++}@>(int op);           // unary postfix increment
int <@\textcolor{red}{?+?}@>(int op1, int op2); // unary postfix increment

struct A { double x, double y }

// overload operator plus-assignment
A ?+?(S a, S b) {
    return (S) {a.x + b.x, a.y + b.y};
}
\end{lstlisting}
\end{frame}
